<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CS106L-01</title>
    <link href="/2025/11/09/CS106L-01/"/>
    <url>/2025/11/09/CS106L-01/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这三讲涵盖了 C++ 的核心基础：编译时 vs 运行时、类型系统、数据组织、以及输入输出。理解这些概念是写好 C++ 的关键。</p><hr><h2 id="第2讲：类型和结构体"><a href="#第2讲：类型和结构体" class="headerlink" title="第2讲：类型和结构体"></a>第2讲：类型和结构体</h2><h3 id="编译-vs-解释"><a href="#编译-vs-解释" class="headerlink" title="编译 vs 解释"></a>编译 vs 解释</h3><p><strong>C++ 是编译型语言：</strong></p><ul><li>编译时：编译器扫描全部代码，检查错误</li><li>运行时：执行已编译的程序</li></ul><p><img src="/image-2.png" alt="alt text"></p><p><strong>对比 Python（解释型）：</strong></p><ul><li>运行时逐行解释和执行</li><li>错误在代码执行到那行时才发现</li></ul><p><img src="/image.png" alt="alt text"> </p><p><strong>关键差异：</strong> C++ 能在你运行代码前就捕捉很多错误！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ❌ C++ 编译报错（类型不匹配）</span><br>std::string hello = <span class="hljs-string">&quot;Hello &quot;</span>;<br>std::string world = <span class="hljs-string">&quot;World!&quot;</span>;<br>std::cout &lt;&lt; hello * world &lt;&lt; std::endl;  <span class="hljs-comment">// 字符串不能相乘</span><br></code></pre></td></tr></table></figure><h3 id="静态类型系统"><a href="#静态类型系统" class="headerlink" title="静态类型系统"></a>静态类型系统</h3><p>C++ 是<strong>静态类型语言</strong>——每个变量必须声明类型，声明后不能更改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>x = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// ❌ 编译错误</span><br><br>std::string s = <span class="hljs-string">&quot;hello&quot;</span>;<br>s = <span class="hljs-number">123</span>;  <span class="hljs-comment">// ❌ 编译错误</span><br></code></pre></td></tr></table></figure><p><strong>为什么要静态类型？</strong></p><ul><li>效率更高（编译器能优化）</li><li>代码更清晰、易理解</li><li>错误更容易发现（编译时而非运行时）</li></ul><h3 id="结构体：打包多个数据"><a href="#结构体：打包多个数据" class="headerlink" title="结构体：打包多个数据"></a>结构体：打包多个数据</h3><p>结构体让你把相关的变量组织在一起。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    std::string name;<br>    std::string id;<br>    <span class="hljs-type">int</span> year;<br>&#125;;<br><br>Student ryan = &#123;<span class="hljs-string">&quot;Ryan&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-number">2</span>&#125;;<br>std::cout &lt;&lt; ryan.name &lt;&lt; std::endl;  <span class="hljs-comment">// &quot;Ryan&quot;</span><br></code></pre></td></tr></table></figure><h3 id="便捷工具"><a href="#便捷工具" class="headerlink" title="便捷工具"></a>便捷工具</h3><p><strong><code>std::pair</code>：两个元素的通用结构体</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;std::string, <span class="hljs-type">int</span>&gt; order = &#123;<span class="hljs-string">&quot;Eggs&quot;</span>, <span class="hljs-number">12</span>&#125;;<br>std::cout &lt;&lt; order.first;   <span class="hljs-comment">// &quot;Eggs&quot;</span><br>std::cout &lt;&lt; order.second;  <span class="hljs-comment">// 12</span><br></code></pre></td></tr></table></figure><p><strong><code>using</code> 关键字：创建类型别名</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> Point = std::pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt;;<br>Point p = &#123;<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>&#125;;  <span class="hljs-comment">// 比写 std::pair 清楚多了</span><br></code></pre></td></tr></table></figure><p><strong><code>auto</code> 关键字：让编译器推断类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">complexFunction</span>();  <span class="hljs-comment">// 编译器自动填入类型</span><br><span class="hljs-comment">// 仍然是静态类型！只是你不用手工写</span><br></code></pre></td></tr></table></figure><hr><h2 id="第3讲：初始化和引用"><a href="#第3讲：初始化和引用" class="headerlink" title="第3讲：初始化和引用"></a>第3讲：初始化和引用</h2><h3 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h3><p><strong>直接初始化（Direct Init）：</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>问题：</strong> 这些方式允许”缩小转换”（narrowing conversion）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">100.8</span>;  <span class="hljs-comment">// 100.8 被静默截断为 100 ⚠️</span><br></code></pre></td></tr></table></figure><p><strong>统一初始化（Uniform Init）：</strong> ✨ 推荐！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x&#123;<span class="hljs-number">100</span>&#125;;      <span class="hljs-comment">// ✓</span><br><span class="hljs-type">int</span> y&#123;<span class="hljs-number">100.8</span>&#125;;    <span class="hljs-comment">// ❌ 编译错误！拒绝缩小转换</span><br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;      <span class="hljs-comment">// 适用所有类型</span><br>std::map&lt;std::string, <span class="hljs-type">int</span>&gt; m&#123;&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><h3 id="结构化绑定（C-17）"><a href="#结构化绑定（C-17）" class="headerlink" title="结构化绑定（C++17）"></a>结构化绑定（C++17）</h3><p>快速从函数返回多个值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;std::string, std::string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;CS106L&quot;</span>, <span class="hljs-string">&quot;Room 110&quot;</span>, <span class="hljs-number">2025</span>&#125;;<br>&#125;<br><br><span class="hljs-keyword">auto</span> [name, room, year] = <span class="hljs-built_in">getInfo</span>();<br>std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; meets in &quot;</span> &lt;&lt; room &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><h3 id="引用：变量的别名"><a href="#引用：变量的别名" class="headerlink" title="引用：变量的别名"></a>引用：变量的别名</h3><p><strong>引用 (<code>&amp;</code>)</strong> 让另一个变量名指向同一块内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span>&amp; ref = x;      <span class="hljs-comment">// ref 是 x 的别名</span><br><br>ref = <span class="hljs-number">10</span>;<br>std::cout &lt;&lt; x;    <span class="hljs-comment">// 输出 10（通过 ref 修改了 x）</span><br></code></pre></td></tr></table></figure><p><img src="/image-1.png" alt="alt text"></p><p><strong>按引用传递函数参数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; n)</span> </span>&#123;<br>    n++;<br>&#125;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">increment</span>(x);<br>std::cout &lt;&lt; x;    <span class="hljs-comment">// 输出 6</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shift</span><span class="hljs-params">(std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; &amp;nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [num1, num2] : nums) &#123; <span class="hljs-comment">// 注意这里也需引用</span><br>        num1++;<br>        num2++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是 pass by value 就不会更改参数数值<br><img src="/image-3.png" alt="alt text"><br><img src="/image-4.png" alt="alt text"></p><h3 id="L值-vs-R值"><a href="#L值-vs-R值" class="headerlink" title="L值 vs R值"></a>L值 vs R值</h3><ul><li><strong>L值</strong>：有内存地址的东西（变量）- 通常在 <code>=</code> 左边</li><li><strong>R值</strong>：临时值，没有固定地址 - 通常在 <code>=</code> 右边</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;      <span class="hljs-comment">// x 是 L值，5 是 R值</span><br><span class="hljs-type">int</span> y = x + <span class="hljs-number">3</span>;  <span class="hljs-comment">// x+3 是 R值（临时计算结果）</span><br></code></pre></td></tr></table></figure><p><strong>关键规则：</strong> 不能绑定非常量引用到 R值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123; &#125;<br><br><span class="hljs-built_in">foo</span>(<span class="hljs-number">5</span>);      <span class="hljs-comment">// ❌ 错误！5 是 R值</span><br><span class="hljs-type">int</span> y = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">foo</span>(y);      <span class="hljs-comment">// ✓ 正确！y 是 L值</span><br></code></pre></td></tr></table></figure><h3 id="const-修饰符"><a href="#const-修饰符" class="headerlink" title="const 修饰符"></a><code>const</code> 修饰符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>x = <span class="hljs-number">10</span>;  <span class="hljs-comment">// ❌ 编译错误</span><br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; ref = vec;  <span class="hljs-comment">// const 引用</span><br>ref.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">// ❌ 不能通过 const 引用修改</span><br></code></pre></td></tr></table></figure><p><strong>记住：</strong> 可以把 const 引用绑定到 L值或 R值上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ref = <span class="hljs-number">5</span>;  <span class="hljs-comment">// ✓ 可以</span><br></code></pre></td></tr></table></figure><hr><h2 id="第4讲：流（Streams）-🌊"><a href="#第4讲：流（Streams）-🌊" class="headerlink" title="第4讲：流（Streams） 🌊"></a>第4讲：流（Streams） 🌊</h2><p>流是 C++ 读写数据的统一接口。你已经用过它了！</p><h3 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h3><p>流像一个”通道”，在你的程序和外部资源（键盘、屏幕、文件）之间传输数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;Hello&quot;</span>;           <span class="hljs-comment">// 输出流（写）</span><br>std::cin &gt;&gt; x;                   <span class="hljs-comment">// 输入流（读）</span><br><span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;  <span class="hljs-comment">// 文件输入流</span><br><span class="hljs-function">std::ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;out.txt&quot;</span>)</span></span>;    <span class="hljs-comment">// 文件输出流</span><br></code></pre></td></tr></table></figure><h3 id="流的继承关系"><a href="#流的继承关系" class="headerlink" title="流的继承关系"></a>流的继承关系</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams">    ios_base<br>       ↓<br>    basic_ios<br>     ↙      ↖<br> istream    ostream      (输入/输出流)<br>  ↙  ↖      ↙  ↖<br><span class="hljs-function"><span class="hljs-title">cin</span></span> istringstream  cout ofstream  ifstream ...<br></code></pre></td></tr></table></figure><h3 id="字符串流：处理字符串如同文件"><a href="#字符串流：处理字符串如同文件" class="headerlink" title="字符串流：处理字符串如同文件"></a>字符串流：处理字符串如同文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::stringstream <span class="hljs-title">ss</span><span class="hljs-params">(<span class="hljs-string">&quot;Bjarne Stroustrup C++ rules&quot;</span>)</span></span>;<br><br>std::string first, last, language;<br>ss &gt;&gt; first &gt;&gt; last &gt;&gt; language;<br><br>std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; last &lt;&lt; std::endl;  <span class="hljs-comment">// &quot;Bjarne Stroustrup&quot;</span><br></code></pre></td></tr></table></figure><p><strong>关键点：</strong> <code>&gt;&gt;</code> 在空白处停止</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string quote = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>ss &gt;&gt; quote;  <span class="hljs-comment">// 只读到 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p><strong>解决方案：使用 <code>getline()</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string wholeLine;<br>std::<span class="hljs-built_in">getline</span>(ss, wholeLine);  <span class="hljs-comment">// 读整行（到换行符）</span><br></code></pre></td></tr></table></figure><h3 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h3><p><strong><code>std::cout</code>：</strong> 标准输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;Hello&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;World&quot;</span> &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p><strong>缓冲和刷新：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;buffered&quot;</span>;       <span class="hljs-comment">// 还在缓冲</span><br>std::cout &lt;&lt; std::flush;       <span class="hljs-comment">// 立即输出</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;line&quot;</span> &lt;&lt; std::endl;  <span class="hljs-comment">// endl = 输出 + 刷新</span><br></code></pre></td></tr></table></figure><p><strong>性能提示：</strong> 用 <code>&#39;\n&#39;</code> 比 <code>std::endl</code> 快（不强制刷新）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 更快 ✓</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>    std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><p><strong>写入文件：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br><span class="hljs-keyword">if</span> (out.<span class="hljs-built_in">is_open</span>()) &#123;<br>    out &lt;&lt; <span class="hljs-string">&quot;Hello CS106L!&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    out.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>读取文件：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::ifstream <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br><span class="hljs-keyword">if</span> (in.<span class="hljs-built_in">is_open</span>()) &#123;<br>    std::string line;<br>    std::<span class="hljs-built_in">getline</span>(in, line);<br>    std::cout &lt;&lt; line &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x;<br>std::cin &gt;&gt; x;  <span class="hljs-comment">// 从键盘读取（空白处停止）</span><br><br>std::string name;<br>std::<span class="hljs-built_in">getline</span>(std::cin, name);  <span class="hljs-comment">// 读整行</span><br></code></pre></td></tr></table></figure><p><strong>常见问题：混用 <code>&gt;&gt;</code> 和 <code>getline()</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> age;<br>std::string name;<br><br>std::cin &gt;&gt; age;  <span class="hljs-comment">// 从输入缓冲读，留下 \n</span><br>std::<span class="hljs-built_in">getline</span>(std::cin, name);  <span class="hljs-comment">// 立即读到那个 \n！得到空字符串</span><br><br><span class="hljs-comment">// 解决方案：</span><br>std::cin &gt;&gt; age;<br>std::<span class="hljs-built_in">getline</span>(std::cin, name);  <span class="hljs-comment">// 消耗剩余的 \n</span><br>std::<span class="hljs-built_in">getline</span>(std::cin, name);  <span class="hljs-comment">// 现在读真正的数据</span><br></code></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>概念</th><th>要点</th></tr></thead><tbody><tr><td><strong>编译 vs 运行</strong></td><td>C++ 编译时捕捉类型错误，更安全高效</td></tr><tr><td><strong>静态类型</strong></td><td>变量类型在声明时确定，之后不能改变</td></tr><tr><td><strong>结构体</strong></td><td>打包相关数据的方式</td></tr><tr><td><strong>统一初始化</strong></td><td>使用 <code>{}</code> 初始化，防止精度丢失</td></tr><tr><td><strong>引用</strong></td><td>变量的别名，用 <code>&amp;</code> 标记</td></tr><tr><td><strong>L&#x2F;R值</strong></td><td>L值有地址，R值是临时的</td></tr><tr><td><strong>const</strong></td><td>防止修改变量或通过引用修改</td></tr><tr><td><strong>流</strong></td><td>统一的输入输出接口</td></tr><tr><td><strong>缓冲</strong></td><td>输出流先缓存，遇到 flush&#x2F;endl 才输出</td></tr></tbody></table><hr><p><strong>核心建议：</strong></p><ul><li>🎯 用统一初始化 <code>{}</code></li><li>🎯 用引用传递大对象（避免复制）</li><li>🎯 理解缓冲机制优化 I&#x2F;O 性能</li><li>🎯 混用 <code>std::cin &gt;&gt;</code> 和 <code>getline()</code> 要小心！</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Japan Trip 2025-2026</title>
    <link href="/2025/11/05/jp-travel/"/>
    <url>/2025/11/05/jp-travel/</url>
    
    <content type="html"><![CDATA[<h2 id="📅-Overview"><a href="#📅-Overview" class="headerlink" title="📅 Overview"></a>📅 Overview</h2><p><strong>日期 Date:</strong> 2025年12月28日 - 2026年1月14日<br><strong>天数 Duration:</strong> 18天<br><strong>路线 Route:</strong> 东京 → 京都 → 大阪 → 札幌 → 洞爷湖 → 函馆 → 札幌</p><ul><li>✈️ <strong>Shanghai → Tokyo Haneda</strong>: 东航 MU539 17:40起飞</li><li>🚄 <strong>Tokyo → Kyoto</strong>: Shinkansen 新干线 (Dec 30)</li><li>🚄 <strong>Kyoto → Osaka</strong>: JR (Jan 4)</li><li>✈️ <strong>Osaka ITM → Sapporo CTS</strong>: 国内航班 (Jan 4)</li><li>🚌 <strong>Sapporo ↔ Lake Toya</strong>: JR特急 (Jan 9)</li><li>🚄 <strong>Lake Toya → Hakodate</strong>: JR (Jan 9)</li><li>🚄 <strong>Hakodate → Sapporo</strong>: JR (Jan 10)</li><li>✈️ <strong>Sapporo CTS → Shanghai PVG</strong>: 新千歳空港 13:50 → 浦东T2 (Jan 14)</li></ul><h2 id="🗓️-Itinerary"><a href="#🗓️-Itinerary" class="headerlink" title="🗓️ Itinerary"></a>🗓️ Itinerary</h2><details close><summary>Day 1-4: Tokyo 东京 (Dec 28-31)</summary><p>Overview  </p><p><img src="/../images/tokyo-00.png" alt="tokyo"></p><p>Dec.29</p><p><img src="/../images/tokyo-01.png" alt="tokyo"></p><p>Dec.30</p><p><img src="/../images/tokyo-02.png" alt="tokyo"><br><img src="/../images/tokyo-02-meiji.png" alt="tokyo"></p><p>Dec.31 (New year’s eve)<br><img src="/../images/tokyo-03.png" alt="tokyo"></p></details><details close><summary>Day 5-8: Kyoto 京都 (Jan 1-4)</summary><p>Overview</p><p><img src="/../images/kyoto-00.png" alt="kyoto"></p><p>Jan.2</p><p><img src="/../images/kyoto-01.png" alt="kyoto"></p><p>Jan.3  </p><p><img src="/../images/kyoto-02.png" alt="kyoto"><br><img src="/../images/kyoto-03.png" alt="kyoto"><br><img src="/../images/kyoto-04.png" alt="kyoto"></p><p>Jan.4 (checkout - 从岚山回来去大阪)</p><p><img src="/../images/kyoto-05.png" alt="kyoto"></p></details><details close><summary>Day 9-18: Sapporo 札幌 (Jan 5-14)</summary><p><img src="/../images/hokkaido-00.png" alt="alt text"><br><img src="/../images/hokkaido-01.png" alt="alt text"><br><img src="/../images/hokkaido-02.png" alt="alt text"><br><img src="/../images/hokkaido-03.png" alt="alt text"><br><img src="/../images/hokkaido-04.png" alt="alt text"></p></details><h2 id="✅-Checklist"><a href="#✅-Checklist" class="headerlink" title="✅ Checklist"></a>✅ Checklist</h2><ul><li><input checked="" disabled="" type="checkbox"> eVisa 电子签证</li><li><input checked="" disabled="" type="checkbox"> Book flights 预订机票</li><li><input disabled="" type="checkbox"> Reserve accommodations 预订酒店</li><li><input disabled="" type="checkbox"> eSIM 准备eSIM卡</li><li><input disabled="" type="checkbox"> Currency exchange 换汇 (50,000 JPY)</li><li><input disabled="" type="checkbox"> Download apps 下载应用</li></ul><h2 id="📝-Notes"><a href="#📝-Notes" class="headerlink" title="📝 Notes"></a>📝 Notes</h2><ul><li>新年期间(12&#x2F;31-1&#x2F;3)许多景点可能调整营业时间</li><li>北海道1月温度约-5°C到-10°C，需准备滑雪装备</li><li>新千岁空港和大阪国際空港提前到达(至少2小时)</li></ul><h2 id="🗺️-Interactive-Map"><a href="#🗺️-Interactive-Map" class="headerlink" title="🗺️ Interactive Map"></a>🗺️ Interactive Map</h2><link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" /><script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script><div id="japan-map" style="height: 480px; width: 100%;"></div><script>// Initialize map centered on Japanvar map = L.map('japan-map').setView([38.5, 138.5], 5);// Add OpenStreetMap tilesL.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {    attribution: '© OpenStreetMap contributors',    maxZoom: 19}).addTo(map);// Tokyo locations (Red)var tokyoIcon = L.icon({    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',    iconSize: [25, 41],    iconAnchor: [12, 41],    popupAnchor: [1, -34],    shadowSize: [41, 41]});L.marker([35.6762, 139.6503], {icon: tokyoIcon}).addTo(map)    .bindPopup('<b>Tokyo 东京</b><br>Dec 28-30');L.marker([35.5494, 139.7798], {icon: tokyoIcon}).addTo(map)    .bindPopup('<b>Haneda Airport 羽田机场</b><br>Arrival Dec 28');// Kyoto locations (Blue)var kyotoIcon = L.icon({    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',    iconSize: [25, 41],    iconAnchor: [12, 41],    popupAnchor: [1, -34],    shadowSize: [41, 41]});L.marker([35.0116, 135.7681], {icon: kyotoIcon}).addTo(map)    .bindPopup('<b>Kyoto 京都</b><br>Dec 30-31, Jan 1-3<br>白鳥駅→京都駅 (新干线)');// Osaka location (Green)var osakaIcon = L.icon({    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',    iconSize: [25, 41],    iconAnchor: [12, 41],    popupAnchor: [1, -34],    shadowSize: [41, 41]});L.marker([34.6937, 135.5023], {icon: osakaIcon}).addTo(map)    .bindPopup('<b>Osaka 大阪</b><br>Jan 4<br>大阪国際空港→新千歳空港 (飞机)');// Hokkaido locations (Orange)var hokkaidoIcon = L.icon({    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-orange.png',    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',    iconSize: [25, 41],    iconAnchor: [12, 41],    popupAnchor: [1, -34],    shadowSize: [41, 41]});L.marker([43.0642, 141.3469], {icon: hokkaidoIcon}).addTo(map)    .bindPopup('<b>Sapporo 札幌</b><br>Jan 5-8, Jan 10-11, Jan 13');L.marker([43.1907, 140.9947], {icon: hokkaidoIcon}).addTo(map)    .bindPopup('<b>Otaru 小樽</b><br>Jan 12<br>札幌手稲滑雪场');L.marker([42.6255, 140.8433], {icon: hokkaidoIcon}).addTo(map)    .bindPopup('<b>Lake Toya 洞爷湖</b><br>Jan 9<br>洞爷湖町');L.marker([41.7688, 140.7290], {icon: hokkaidoIcon}).addTo(map)    .bindPopup('<b>Hakodate 函馆</b><br>Jan 9-10<br>函馆城市');L.marker([42.7791, 141.6866], {icon: hokkaidoIcon}).addTo(map)    .bindPopup('<b>New Chitose Airport 新千歳空港</b><br>Jan 14<br>新千歳空港 1350→浦东T2');</script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>roadmap</title>
    <link href="/2025/10/28/roadmap/"/>
    <url>/2025/10/28/roadmap/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>C&#x2F;C++ </p><ul><li><input disabled="" type="checkbox"> CS106L <a href="https://web.stanford.edu/class/cs106l/">link</a></li></ul><p>CUDA <a href="https://docs.nvidia.com/cuda/">tut</a>  </p><ul><li><input disabled="" type="checkbox"> CUDA &amp; GPU architecture</li><li><input disabled="" type="checkbox"> NCU</li><li><input disabled="" type="checkbox"> cutlass</li><li><input disabled="" type="checkbox"> cutedsl</li></ul><p>Pytorch <a href="https://docs.pytorch.org/tutorials/index.html">tut</a>  </p><ul><li><input disabled="" type="checkbox"> intro  </li><li><input disabled="" type="checkbox"> torch.compile</li><li><input disabled="" type="checkbox"> domain</li><li><input disabled="" type="checkbox"> ddp</li><li><input disabled="" type="checkbox"> deepdive</li><li><input disabled="" type="checkbox"> recipes</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Books 2025</title>
    <link href="/2025/10/14/books-2025/"/>
    <url>/2025/10/14/books-2025/</url>
    
    <content type="html"><![CDATA[<h1 id="杀死一只知更鸟"><a href="#杀死一只知更鸟" class="headerlink" title="杀死一只知更鸟"></a>杀死一只知更鸟</h1><p>为什么人们憎恨希特勒,却无法与黑人和平共处?一个和谐的小镇,却弥漫着白人至上主义。也许我们终究只是情绪的奴隶——看似团结一致,却无法独立思考。人们看不到汤姆·鲁宾逊只是一个乐于助人的黑人青年,看不到阿提克斯只是试图在法庭上指出这个关键问题。我们能否放下所有立场,放弃我们的信念,仅从事实和逻辑出发,站在他人的角度重新审视我们之前的所有判断?</p><blockquote><p>“你永远不会真正了解一个人,除非你从他的角度去思考问题……除非你钻进他的皮肤里,像他一样行走。”</p></blockquote><blockquote><p>“我想让你看到什么是真正的勇气,而不是认为勇气就是一个手里拿着枪的人。真正的勇气是,在你还没开始之前就知道自己会输,但你仍然要开始,并且无论如何都要坚持到底。”</p></blockquote><span id="more"></span><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../images/to-kill-a-mockingbird.png" alt="To Kill a Mockingbird&#39; : 1962 Movie"></h2><h1 id="焦虑的人"><a href="#焦虑的人" class="headerlink" title="焦虑的人"></a>焦虑的人</h1><p>我们都被过去所困。如果当初做了 a、b、c,我可能会到达一个更好的地方。我们应该做好孩子、好朋友、好父母、好邻居。我们承载着生活的重量——工作、学习、社会。我们崩溃只是时间问题。</p><blockquote><p>“有些人接受自己永远无法摆脱焦虑,他们只是学会了承载它。她试图成为他们中的一员。她告诉自己,这就是为什么你应该善待他人,即使是傻瓜,因为你永远不知道他们的负担有多重。”</p></blockquote><p>致所有焦虑的人:不要害怕,这不是你的错。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/../images/anxious-people.png" alt="Anxious People"></h2><h1 id="月亮与六便士"><a href="#月亮与六便士" class="headerlink" title="月亮与六便士"></a>月亮与六便士</h1><p>他抛弃了妻子和孩子,逃到一个陌生的地方独自作画。我们应该从传统道德的角度谴责他,还是应该欣赏他的自由和不羁精神?他勾引了恩人的妻子,最终却抛弃了她,导致她自残并抑郁而死。然而,即使他的恩人准备离开这个伤心之地,他也无法下定决心毁掉这个男人的画作以示报复。我们应该对这个软弱的人感到愤怒,还是应该谴责这个罪孽深重的人?最终,什么更重要——遵守规则、养育孩子,还是违背常规、自由地活在世界上?</p><blockquote><p>“我不知道亚伯拉罕是否真的毁了自己的生活。做你热爱的事,在你喜欢的环境中平静地生活——这真的算毁了人生吗?一定要成为年薪一万英镑的著名外科医生,拥有一位美丽的妻子,才算成功吗?我认为成功取决于你如何看待生命的意义,你能为社会履行什么义务,以及你对自己有什么要求。然而,我仍然困惑——我是谁,我有什么资格与一位骑士争论?”</p></blockquote><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/../images/the-moon-and-sixpence.png" alt="The Moon and Sixpence: 1942 Movie"></h2><h1 id="你当像鸟飞往你的山"><a href="#你当像鸟飞往你的山" class="headerlink" title="你当像鸟飞往你的山"></a>你当像鸟飞往你的山</h1><p>一个狂热迷信的父亲,一个沉默顺从的母亲,一个暴力危险的哥哥,一个背叛她的姐姐。教育让她与这个家庭对立——从深陷其中,到渴望教育,到经历思想转变,最后到家庭关系的破裂。她是狂热宗教灌输的受害者,但最终,她以不妥协的态度,原谅了她的原生家庭。</p><h1 id="被侮辱与被损害的"><a href="#被侮辱与被损害的" class="headerlink" title="被侮辱与被损害的"></a>被侮辱与被损害的</h1><p>人类的所有的行为，选择，举止，都深刻的被自身底层的欲望所掌控，无论是可恶的剥削者还是可怜的穷人们。剥削者带着一种玩弄的态度，随意的侮辱以及损害他人。穷人带走一种悲哀的，甚至可笑的决绝的态度，斩断一切与剥削者的联系，甚至于可能伤害到自己，虚幻的正直感是他们唯一的遗物，可悲地活着。 </p><p><img src="/../images/humiliated-and-insulted.png" alt="人物关系"></p><p>娜塔莎背弃了自己的家人去找阿廖沙，带着一种病态的母爱式的爱情观念：对于幼稚无脑的，常常移情别恋的阿廖沙，她深陷于原谅他的快感中。家人的诅咒，公爵的陷害，都让她身心俱疲，感情也是无疾而终。</p><p>卡佳也并非明智，即使知道公爵的诡计，她也无法逃过自己的欲望。像一个孩子王，她深陷让阿廖沙敬仰自己的快乐。被公爵深深掌控的二人，未来暗淡。</p><p>三人复杂的关系承载了全文80%的痛苦。父亲尼古拉本是公爵的敬仰者，但无非是被剥削者的一厢情愿。被诬陷以及侮辱后，她深陷对公爵的仇恨，甚至将它转嫁到对自己女儿身上。爱着她，同时憎恨者她。</p><p>一切看似以娜塔莎回家结束，内莉的死将所有的痛苦在最后一刻释放。悲惨的孤女，从出生前被公爵抛弃，母女在大街艰难维生，外公对一切也是痛恨万分（类比尼古拉）。母亲告诫要当一辈子的穷人，拒绝一切，只能打工或者乞讨。母亲死后被我所救。来自他人的爱让内莉不解，她起初痛苦的拒绝一切，最后被我和两位老人的关心感化。最终在所有人的包围中，因病去世。</p><blockquote><p>“万尼亚，你叫他们进来吧，”她终于有气无力地说道，“我要跟他们大家告别。永别了，万尼亚！……” 她最后一次紧紧地、紧紧地拥抱了我。我们的人都进来了。老爷子没法明白，她怎么就要死了呢；他不容许有这样的想法。他直到最后一刻都跟我们大家争论，硬说她的病一定会好起来的。因为日夜操劳，他整个人瘦了一圈，他整天整天地在病榻旁陪着内莉，甚至夜里也不走……最后几夜他根本就没睡。他极力先意承志地满足内莉最微小的任性的要求和最微小的愿望，每当他离开她上我们这边来，他就掩面痛哭，但是过了一分钟，他又开始充满希望，而且硬要我们相信她的病肯定会好起来的。他把鲜花堆满了她的房间。有一回，他买回了一大把娇艳欲滴的月季花，红的和白的，他为了买这些花跑了很远的路，然后拿回来送给他的内莉奇卡……凡此种种，他使她感到分外激动。对环绕在她四周的爱，她不能不用自己的整个心来回报大家。那天晚上，在她跟我们临终告别的那天晚上，老爷子怎么也不肯跟她诀别。内莉向他粲然一笑，整个晚上都极力装出一副很开心的样子，跟他闹着玩，甚至还笑了……我们大家从她屋里走出来时几乎都还抱着希望，但是到第二天，她已经不能说话了。两天后她就死了。我记得，老爷子怎样用鲜花把她的小棺材装饰起来，他怎样伤心欲绝地望着她那瘦削的、已经死气沉沉的小脸蛋，望着她那死后的笑容，望着她那十字交叉地放在胸前的胳臂。他像哭自己的亲生孩子那样哭她。娜塔莎、我，我们大家都安慰他，但是他没法得到安慰，内莉下葬后，他生了一场大病。</p></blockquote><p><em><strong>如果你想得到别人的尊重，最重要的是尊重自己。只有这样，只有自尊，你才能迫使别人尊重你。</strong></em></p><h1 id="白夜行"><a href="#白夜行" class="headerlink" title="白夜行"></a>白夜行</h1><blockquote><p>我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。</p></blockquote><h1 id="雪国"><a href="#雪国" class="headerlink" title="雪国"></a>雪国</h1><p><img src="/../images/%E9%9B%AA%E5%9B%BD.png" alt="alt text"></p><blockquote><p>穿过界限长长的隧道，便是雪国。夜空下，大地一片莹白。</p></blockquote><p>在大雪覆盖的雪国，岛村和艺伎驹子交往着，同时向往美丽纯洁的叶子。住在乡下蚕房的驹子，即使学得一手好琴，即使对当下名著侃侃而谈，在岛村眼里不过是大雪之下，驹子在村中无谓的行为。对于纨绔子弟，他把自己对雪国美好的向往，寄托于纯洁的叶子，但一切都随着叶子在大火中丧生，戛然而止。</p><h1 id="一个叫欧维的男人决定去死"><a href="#一个叫欧维的男人决定去死" class="headerlink" title="一个叫欧维的男人决定去死"></a>一个叫欧维的男人决定去死</h1><p>在读</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
